/*
 ОБЩИЕ ТЕЙЗИСЫ =================================================
 
 * В переменных хранятся только числа и ничего кроме чисел, но другое дело, что эти числа могут быть интрепретированы как угодно.
 * Pass by value  -  аргументы в функцию передаются по значению6 то есть создаются их копии, в этой связи вне функции они не остаются прежними.
 * Адрес переменной  -  это адрес её младшего байта.
 * typedef тип псевдоним;  -  даём свой псевдоним ккакому-либо типу.
 * #define ИМЯ значение (#define A 34 или #define cube(x) x * x * x) - это макрос, теперь везде где мы будем писать А, компелятор будет подставлять 34 (У макроса в отличии от функции нет типов, аргументов, возвращаемого значения).
    Правила написания макроса:
        - обрамляем в скобки все выражение и каждый его член sum(a, b) (a + b)
        - каждый аргумент обрамляем в скобки square(x) ((x) * (x))
        - не совать в качестве аргумента x--, x++, --x, ++x итд.
 * Табуляцыей в языке си принято считать 8 пробелов.
 * В языке СИ есть неписанное правило, если в коде более трех отступов табуляции, значит код надо переписывать он не правильно составлен.
 * 
 
 
 Таблицв ASCII кодов -------------------------------------------
 БИТ - 0 или 1
 БАЙТ - 8 бит
 Базавая таблица кодирования от 0 до 127 первых символов.
 Десятичные цыфры - от 48 до 57
 Латинские буквы в нижнем регистре - от 97 по 122
 Латинские буквы в верхнем регистре - от 65 до 90
 Знаки припенания - в разброс
 Управляющие коды - от 0 до 31 кода
 Расширеная таблица от 128 до 255 символов.
 Символы национальных алфавитов
 Символы псевдографики
 
 Escape sequence -----------------------------------------------
 1. \n  -  перенос строки
 2. \r  -  курсор в начало текущей строки
 3. \t  -  табуляция кратная 8-ми символам
 4. \b  -  удаление символа
 5. \"  -  "
 6. \'  -  '
 7. \\  -  \
 8. \a  -  звуковой сигнал
 
 Форматирование --------------------------
 Спецыфикаторы формата:
 %d  -  decimal Десятичный
 %o  -  octal Восьмеричный
 %x  -  hex Шестнадцатиричный
 %s  -  string Строка
 %c  -  char Символ
 %u  -  unsigned Беззнаковое десятичное
 %f  -  float С плавающей точкой
 %lf  -  double С плавающей точкой повышенной точности
 %p  -  pointer Указатель
 Модификаторы формата:
 %6d  -  под данное число будет отведено 6 позиций
 %.2f  -  печатать 2 знака после запятой
 %06.2f  -  заполнить нулями предшествующие позиции
 %e  -  экспаненциальный вывод очень больших/маленких чисел (3 * 10 в степени -23     =     3e-23     [double x = 3e-23;])
 
 Краткие формы записи операций ---------------------------------
 x += 2      x = x + 2
 x -= 3      x = x - 3
 x *= 5      x = x * 5
 x /= 3      x = x / 3
 x++         x = x + 1
 x--         x = x - 1
 
 Типы данных ---------------------------------------------------
 Целочисленные:
 char  [-128 - 127] (самый маленький тип для зранения целых чисел)
 short
 int
 long
 long long
 С плавающей точкой:
 float
 double
 Спецыфикаторы:
 signed
 unsigned
 В ПРЯМОМ КОДЕ в знаковых числах, за то, положительное или отрицательное это число отвечает старший бит 1011 = -3 ,а 0011 = 3  -  в прошлом.
 В ОБРАТНОМ КОДЕ в знаковых числах, что бы из положительного 0011 = 3 сделать отрицательное 1100 = -3 нужно поменять местами нолики и единички  -  в прошлом.
 В ДОПОЛНИТЕЛЬНОМ КОДЕ в знаковых числах, что бы из положительного 0011 = 3 сделать отрицательное 1100 = -3 нужно поменять местами нолики и единички И ПРИБАВИТЬ 1  -  !!!актуальнр!!!
 
 Преоброзование типов ------------------------------------------
 Явное:
 (int)2.5;      //  2
 (int)(x + y)
 При явном преоброзовании числа с плавающей точкой к целочисленому дробная часть всегда отбрасывается независимо от её велечины.
 Неявное:
 int x = 2.6                                                //  2
 double x = 7 / 3                                           //  2   так как 7 и 3 целочисленные (от осинки не родятся апельсинки)
 double x = 7 / 3.0 или 3. или 3f или (double)3             //  2.333...
 Неявное преоброзование типов осуществляется в следующих случаях:
    1 перед передачей аргументов в функцию (если тип передаваемого значения отличается от типа аргумента)
    2 выполнение арифметических операций с азными типами
    3 перед выполнением присваивания
 Преоброзование осуществляется:
 - от простого к сложному при int и double будет double
 - от signed к unsigned
 - от короткого к длинному при int и long будет long
 - при присваивании значение справа от оператора присваивания приводится к типу переменной слева от присваивания
 
 Преоритет выполнения операцый ---------------------------------
 1  вычисляются функции (например, sqrt(), cos() и др.)
 2  умножение, деление, остаток от деления (слева направо)
 3  сложение, вычитание
 4  выполняется присваивание
 
 Константы -----------------------------------------------------
 12         -   десятичная константа int
 12L        -   десятичная константа long
 12u        -   десятичная константа unsigned
 3.14       -   double
 3.14f      -   float
 1e9        -   1 * 10^9
 'z'        -   символная константа
 "Hello"    -   строковая константа
 012        -   десятичное число 10 записанное в восьмиричной системе
 0x12       -   десятичное число 18 записанное в шестнадцатиричной системе
 
 Характеристики переменной -------------------------------------
 ИМЯ
 ТИП
 ЗНАЧЕНИЕ
 ОБЛАСТЬ ВИДИМОСТИ
 ВРЕМЯ ЖИЗНИ
     Локальная переменная:
         оласть видимости  -  от места дикларации до конца соответствуюзего блока
         время жизни  -  до конца выполнения этого блока
         начальное значение  -  мусор
     Аргументы функции:
         оласть видимости  -  функция
         время жизни  -  до конца выполнения этой функции
         начальное значение  -  значение аргумента при вызове функции
     Глобальные переменные:
         оласть видимости  -  от декларации до конца файла (область может расшириться на другие файлы)
         время жизни  -  время выполнения программы
         начальное значение  -  0
             extern  -  данное ключевое слово при обявлении глобально переменной (как правило в хедере), позволяет в данном файле использовать перменную объявленную в другом файле (файл первый: int x = 5; [в данном случаем мы определяем переменную x так как при инициализции ей значения выделяется память]  файл второй: extern int x; [в данном случаем мы объявляем, что есть такая переменная x которая объявлена в другом файле и мы хотим её использовать])
     static локальная переменная:
         оласть видимости  -  в данном блоке
         время жизни  -  время выполнения программы
         начальное значение  -  0
         (слатическая локальная переменная это переменная, которая видна в  том блоке где была определена но по завершении блока не уничтожается, то есть, сохраняет свое значение между вызовами данного блока)
 
 Разница между x++ и ++x ---------------------------------------
 #include <stdio.h>
 int main() {
     int x = 2;
     printf("%d", x++); //2
     printf("%d", x);   //3
     printf("%d", ++x); //4
     printf("%d", x);   //4
     return 0;
 }
 
 Дерективы препроцессора ---------------------------------------
 #include <имяФайла> или "имяФайла" -  подключение файла.
     #include <string.h>
     #include "functions.h"
 #define КОНСТАНТА или МАКРОС значение  -  создание констнант или создание макроса
     #define MAX_LANG 2000  -  константа.
     #define square(x) ((x)*(x))  -  макрос.
     #define myPrint printf("%d", MAX_LANG)
 #undef МАКРОС  -  отменяет значение макроса (после этого можем создать макрос с тем же именем, но другим значением)
 #define КОНСТАНТА или МАКРОС  -  создание констнант или создание макроса без значения.
     #define MAX_LANG
         #ifdef MAX_LANG  -  начало блока условной компеляции.
         какойто код  -  код обрамлённый сверху #ifdef и снизу #endif будет выполняться тольео если ранее был определён макрас, имя которого, идёт после #ifdef, в нашем случае MAX_LANG
         #else
         какойто код  -  код который будет выполняться если макрос не был определён.
         #endif  -  завершение блока условной компеляции.
 #ifndef MAX_LANG
 код  -  выполняется если макрос не был определён.
 #else
 код  -  выподняется если мкрос был определён.
 #endif
         #if MAX_LANG > 1500
         код
         #elif MAX_LANG < 500
         код
         #else
         код
         #endif
 
 Рекурсивный вызов функции ------------------------------
        Числа Фибаначи:
        0 1 2 3 4 5  6  7
        1 1 2 3 5 8 13 21
    - неэффективная реализация
 #include <stdio.h>
 int fib(int n);
 int main() {
     puts("Введите положительное число.");
     int num;
     scanf("%d", &num);
     printf("Для числа  %d, число Фибаначи будет %d\n", num, fib(num));
     return 0;
 }
 int fib(int n) {
     if (n == 0 || n == 1)
         return 1;
     return fib(n - 1) + fib(n - 2);
 }
    - эффективная реализация
 
  Проверка на стиль при помощи clang-format ------------
 1. Помещаем файл .clang-format в директорию надо/с файлом с исзодником.
 2. В консоле запускаем команду clang-format -i имяФайла.c  -  автоматически исправляет все стилевые ошибки.
 3. clang-format -n имяФайла.c  -  проверяет на стиль
    - В switch-case всё должно быть на разных строчках
    - Смещение должно быть в 2 пробера (не 4, не 8, не tab)
 
 
 
 
*/

