/*
ФУНКЦИИ СТАНДАРТНЫХ БИБЛИОТЕК =========================================
 
 ====== stdio.h =======
 1)     GETCHAR()  -  
 int getchar(void) {
 
 }
 
 2)     PRINTf()  -  Преобразует, форматируе и печатает свои аргументы в ствндартный вывод, возвращает колличество напечатанных символов.
    Спецыфикаторы формата:
 %d  -  decimal Десятичный
 %o  -  octal Восьмеричный беззнаковое
 %x  -  hex Шестнадцатиричный
 %s  -  string Строка
 %c  -  char Символ
 %u  -  unsigned Беззнаковое десятичное
 %f  -  float С плавающей точкой
 %lf  -  double С плавающей точкой повышенной точности
 %p  -  pointer Указатель
 %%  -  Печать знака профента
    Модификаторы формата:
 %6d  -  под данное число будет отведено 6 позиций
 %.2f  -  печатать 2 знака после запятой
 %06.2f  -  заполнить нулями предшествующие позиции
 - - выравнивание преобразованных аргументов по левому полю.
 - число задает ширину поля.
 - точка разделитель
 - второе число определяет точность (максимальное колличество символов в строке или цыфр после запятой).
 - h если печатаемое целое должно рассматриваться как short.
 - l если как long.
 - * обозначает точность которая принемается в виде аргумента типа int printf("%.*s", max, s);
 int printf(char* format, arg1, arg2, ...) {
 
 }
 
 3)     SPRINTF()  -  То же самое, что и printf(), но результат выводится в строку str.
 int sprintf(cha* str, char* format, arg1, arg2, ...) {
 
 }
 
 4)     SCANF()  -  считывает данные из стандартного ввода интерпретирует из согласно спецыфикаторам формата и рассылает в остальные аргументы, возвращает колличество успешно усвоенных элементов, по исчерпанию источника она выдает EOF, если первый обрабатываемый символ не соответствует спецыфикации то возвращается 0.
    Спецыфикатооры формата:
 - пробелы и табуляции, которые обычно игнорируются
 - обычные символы, которые совпадут с символами из потока и будут проигнорированы
 - спецыфикации преоброзования, начинающиеся с %
    Модификаторы формата:
 - * признак подавления присваивания
 - число определяющее ширину поля (максимум до следующего разделителя, символы разделители [пробела, табуляции, новой строки, возврата каретки, вертикальной табуляции и перевода страницы.])
 - h l L символы указывающие на размер получаемого значения
 - o d x символы преобразования
 
 int scanf(char *format, ...) {
 
 }
 
 5)     SSCANF()  -  читает не из стандартного ввода, а из строки.
 int sscanf(char *string, char *format, arg1, arg2, ...) {
 
 }
 
 6)
 
 
 
 ====== stdlib. =======
 
 1)      RAND()  -  Функция возвращает случаеное целое число в диапазоне от 0 до RAND_MAX(константа языка СИ в которой содержится максимальное целое число, которое возвращает функция rand()).
 int rand(void);
 printf("%d\n", rand());
 Получение случайногочисла в определённом диапазоне:
    - случайное число меньше 100
 printf("%d\n", rand() % 100);
    - случайное число от 80 до 100 не включительно    или     в диапазоне от x до y не включительно.                или      включительно
 printf("%d\n", (80 + 1) + rand() % (100 - 80));      или     printf("%d\n", (x + 1) + rand() % (y - x));           или      printf("%d\n", x + rand() % (y - x + 1));
 Проблема этой функции заключается в том, что она генерирует идни и теже числа, при каждом запуске программы и что бы этого избежать нам надо использовать функцыю srand().
 
 2)     SRAND()  -  Функция генерации случайных чисел на основе посланного в качестве аргумента числа и влияет на функцию rand() так, что при каждом запуске она будет генерировать новые случайный числа так как количество секунд прошедших с 0 часов 1-ого января 1970 года всегда будет разное.
 void srand(unsigned int seed);
 Код генерации случаных числе на основе изменения времени:
 srand(time(NULL));
 printf("%d\n", rand() % 100);
 
 ====== unistd.h =======
 
 
 ====== math.h =======
 1)     fABS()  -  модуль числа x.
 double fabs(double x);
 
 2)     SQRT()  -  квадратный корень из числа x.
 double sqrt(double x);
 
 3)     SIN()  -  синус числа x (х в радианах).
 double sin(double a);
 
 4)     COS()  -  косинус числа x (х в радианах).
 double cos (double a);
 
 5)     POW()  -  возводит x в степень y.
 double pow(double x, double y);
 
 6)     EXP()  -  возводит число e (основание натурального логарифма) в степень x.
 double exp(double x);
 
 7)     LOG()  -  натуральный логарифм числа x.
 double log(double x);
 
 8)     lOG10()  -  десятичный логарифм числа x.
 double log10(double x);
 
 9)     MODF()  -  функция отделяющая у числа x целую часть от дробной, а указатель c указывает на переменную в которую помещается целая часть аргумента x.
 double modf(double x, double *с);
 
 ПРИМЕЧАНИЕ: Длинна любой окружности больще диаметра окружности в пи (3.14...) раз, а радиан это угол внутри окружности отмереный при помощи радиуса этой окружности и равен примерно 57 градусам. [градусы = 180 / пи * радианы        радианы = пи / 180 * градусы]
 
 
 ====== string.h =======
 1)     STRCPY()  -  Копирует строку src в строку dest включая '\0' и возвращает адрес строки dest.
 char* strcpy(char* dest, const char* src) {
     char* p = dest;
     if (dest == NULL)
         return NULL;
     while (*src != '\0') {
         *dest = *src;
         dest++;
         src++;
     }
     *dest = '\0';
     return p;
 }
 
 2)     STRNCPY()  -  Копирует строку src в строку dest включая '\0', но не более n элементов и возвращает адрес строки dest.
 char* strncpy(char* dest, const char* src, size_t num) {
     char* p = dest;
     if (dest == NULL)
         return NULL;
     while (*src != '\0' && num != 0) {
         *dest = *src;
         dest++;
         src++;
         num--;
     }
     *dest = '\0';
     return p;
 }
 
 3)     STRCAT()  -  Приписывает содержимое строки src к строке dest и добавляет '\0' в конце и возвращает укзатель на строку dest.
 char* strcat(char* dest, const char* src) {
     char* p = dest;
     if (dest == NULL)
         return NULL;
     while (*dest != '\0')
         dest++;
     while (*src != '\0') {
         *dest = *src;
         dest++;
         src++;
     }
     *dest = '\0';
     return p;
 }
 
 4)     STRNCAT()  -  Приписывает содержимое строки src к строке dest, но не более n элементов и добавляет '\0' в конце и возвращает укзатель на строку dest.
 char* strncat(char* dest, const char* src, size_t num) {
     char* p = dest;
     if (dest == NULL)
         return NULL;
     while (*dest != '\0')
         dest++;
     while (*src != '\0' && num != 0) {
         *dest = *src;
         dest++;
         src++;
         num--;
     }
     *dest = '\0';
     return p;
 }
 
 5)     STRCMP()  -  Сравнивает две строки и в случае совподения возвращает 0, ести не равны возвращает разницу между ascii кодами несовпавших элементов str1 и str2.
 int strcmp(const char* str1, const char* str2) {
     while (*str1 == *str2) {
         if (*str1 == '\0')
             return 0;
         str1++;
         str2++;
     }
     return *str1 - *str2;
 }
 
 6)     STRNCMP()  -  Сравнивает две строки, но не более n элементов и в случае совподения возвращает 0, ести не равны возвращает разницу между ascii кодами несовпавших элементов str1 и str2.
 int strncmp(const char* str1, const char* str2, size_t num) {
     while (*str1 == *str2 && num != 1) {
         if (*str1 == '\0')
             return 0;
         str1++;
         str2++;
         num--;
     }
     return *str1 - *str2;
 }
 
 7)     STRCHR()  -  Функция ищет первое вхождение символа в строку и возвращает его адрес или NULL если такого не обнаружено.
 char* strchr(const char* str, int c) {
     while (*str != '\0') {
         if (*str == c)
             return (char*)str;
         str++;
     }
     return NULL;
 }
 
 8)     STRRCHR()  -  Функция ищет первое вхождение символа в строку и возвращает его адрес или NULL если такого не обнаружено.
 char* strrchr(const char* str, int c) {
     char* p = NULL;
     while (*str != '\0') {
         if (*str == c)
             p = (char*)str;
         str++;
     }
     return p;
 }
 
 9)     STRSPN()  -  Функция возвращает колличество элементов от начала строк str1 совпадающих без пропусков с элементами находящимес в строке str2.
 size_t* strspn(const char* str1, const char* str2) {
     size_t count = 0;
     char bigFlag = 0;
     while (*str1 != '\0') {
         const char* tmpStr2 = str2;
         char flag = 0;
         while (*tmpStr2 != '\0') {
             if (*str1 == *tmpStr2) {
                 flag = 1;
                 break;
             }
             tmpStr2++;
         }
         if (flag) {
             count++;
             bigFlag = 0;
         } else
             bigFlag = 1;
         str1++;
         if (!flag && !count)
             return count;
         if (bigFlag && count)
             return count;
 }
 return count;
 }
 
 10)    STRCSPN()  -  Функция возвращает колличество элементов от начала строк str1 несовпадающих без пропусков с элементами находящимес в строке str2.
 size_t* strspn(const char* str1, const char* str2) {
     size_t count = 0;
     while (*str1 != '\0') {
         const char* str2Tmp = str2;
         while (*str2Tmp != '\0') {
             if (*str1 == *str2Tmp)
                 return count;
             str2Tmp++;
         }
         count++;
         str1++;
     }
     return count;
 }
 
 11)    STRPBRK()  -  Функция возвращает адрес первого элемента в строке str1 совпавшего одним из элементов в строке str2
 char* strpbrk(const char* str1, const char* str2) {
     while (*str1 != '\0') {
         const char* str2Tmp = str2;
         while (*str2Tmp != '\0') {
             if (*str1 == *str2Tmp)
                 return (char*)str1;
             str2Tmp++;
         }
         str1++;
     }
     return NULL;
 }
 
 12)    STRSTR()  -  Функция возвращает адрес первого вхождения строки str2 в строку str1, если строка str2 содержит только символ конца строки '\0' то функция вернёт адрес первого элемента str1, если строка str2 не входит в строку str1 то функция верёт NULL.
 char* strstr(const char* strB, const char* strA) {
     if (!(*str2))
         return (char*)str1;
     while (*str1 != '\0') {
         char flag = 0;
         if (*str1 == *str2) {
             char* str2Tmp = (char*)str2;
             char* str1Tmp = (char*)str1;
             while (*str2Tmp != '\0') {
                 if (*str1Tmp == *str2Tmp) {
                     flag = 1;
                     str1Tmp++;
                     str2Tmp++;
                 } else {
                     flag = 0;
                     break;
                 }
             }
             if (flag)
                 return (char*)str1;
         }
         str1++;
     }
     return NULL;
 }
 
 13.    STRLEN()  -  Функция возвращающая длинну строки.
 size_t strlen (const char *str) {
     size_t size = 0;
     while (*str != '\0') {
         size++;
         str++;
     }
     return size;
 }
 
 14.    STRTOK()  -  Разбиение строки на части по одному из указанных в массиве sep указателей, возвращает NULL если строку str нельзя разбить ни одним из разделителей из массива sep и адрес указатель на первый символ выделенной части строки.
 char* strtok(char* str, const char* sep) {
 
 }
 
 15.    STREROR()  -
 
 
 
 ====== time.h =======
 1)     TIME()  -  Функция считывает текущие показания часов CLOCK_REALTIME (системных часов) в секундах. Значение системных часов – это время в секундах, истекшее с 0 часов 1 января 1970 года и возвращает текущее время в секундах, а так же в качестве аргумента можно послать адрес переменной в которую будет записано это время или послать NULL если записывать не нужно.
 time_t time(time_t* ttime);
 
 ====== assert.h ======
 
 
 
 ====== float.h ======
 
 
 
 ====== stdarg.h ======
 
 
 
 ====== ctype.h ======
 
 
 
 ====== limits.h ======
 
 
 
 ====== setjmp.h ======
 
 
 
 ====== stddef.h ======
 
 
 
 ====== errno.h ======
 
 
 
 ====== locale.h ======
 
 
 
 ====== signal.h ======
 
 
 ДРУГИЕ БИБЛИОТЕКИ
 
 ====== getopt.h =======
 1)   GETOPT_LONG()  -  Данная функция парсит короткие и длинные аргументы функции main().
 int getopt_long(int argc, const char* argv[], const char* optstring, const struct option* longopts, int* longindex)
 
 ВОЗВРАЩАЕТ  -  ascii код считанного аргумента функции main() или -1 если считанного аргумента нет в списке параметров данной программы.
 int argc  -  колличество аргументов функции main() (первый то есть нулевой аргумент всегда название программы)
 const char* argv[]  -  адрес первого элемента аргументов командной строки.
 const char* optstring  -  адрес первого элемента строкового литерала содержащего перечисление возмодных коротких аргументов командной строки (со всеми доп символами на подобии :)
         -с или --currensy  -  параметр командной строки.
         -с:usd  -  после : то есть usd это опция (обязательная) параметра командной строки -с или --currensy и указатель на этот параметр присвается переменной optarg.
         -с::usd  -  после :: то есть usd это опция (необязательная) параметра командной строки -с или --currensy и указатель на этот параметр присвается переменной optarg.
 const struct option* longopts  -  адрес первого элемента массива структур состоящего из пересислений (длинноеИмяАргумента, НаличиеОпции, адресЗаписиЗначенияПоляValue (если NULL то будет возвращено в качестве возвращаемого функцией значения), возвращаемоеЗначени)
         struct option{
              const char *name;
              int has_arg;
              int *flag;
              int val;
         };
 int* longindex  -  адрес переменной счетчика колличества считанных аргументов.
 ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ:
 extern char* optarg;  -  содержит опцыю аргумента, обратанного на последней итерации.
 extern int optopt;  -  содержит ascii код последнего, обработанного аргумента не содержащегося в строке optstring.
 
 int main(int argc,char * argv[]) {
     struct option longOpts[] = {
         {"currency", 1, NULL, 'c'},
         {"margin", required_argument, NULL, 'm'},
         {0, 0, 0, 0}
     };
     char ch;
     while ((ch = getopt_long(argc, argv, "c:m:", longOpts, NULL)) != EOF) {
         switch (ch) {
             case 'c': strcpy(currency, optarg); break;
             case 'm': margin = atoi(optarg); break;
         };
     }
     argc -= optind;  //->  мы убрали из общего колличества аргументов функции main() название программы и параметры
     argv += optind;  //->  мы переместились на адрес первого настоящего аргумента функции main()
     return 0;
 }

 */

